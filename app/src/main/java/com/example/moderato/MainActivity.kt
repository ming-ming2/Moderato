package com.example.moderato

import android.app.AlertDialog
import android.content.Intent
import android.graphics.Color
import android.graphics.Typeface
import android.os.Bundle
import android.view.Gravity
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import java.text.SimpleDateFormat
import java.util.*

class MainActivity : AppCompatActivity() {

    private lateinit var btnNotification: ImageButton
    private lateinit var btnSettings: ImageButton
    private lateinit var emotionStaffView: EmotionStaffView
    private lateinit var emotionTimelineContainer: LinearLayout
    private lateinit var tvEmptyMessage: TextView
    private lateinit var btnAddEmotion: Button
    private lateinit var btnEmotionTuner: Button

    private lateinit var todayChordCard: LinearLayout
    private lateinit var tvChordSymbol: TextView
    private lateinit var tvChordName: TextView
    private lateinit var tvChordFullName: TextView
    private lateinit var tvIntensity: TextView
    private lateinit var tvChordMessage: TextView
    private lateinit var tvEmotionCount: TextView
    private lateinit var tvDominantEmotion: TextView
    private lateinit var btnPlayChord: Button
    private lateinit var btnShareChord: Button

    private lateinit var fileManager: EmotionFileManager
    private lateinit var chordAnalyzer: EmotionChordAnalyzer
    private lateinit var chordHistoryManager: ChordHistoryManager
    private val emotionData = mutableListOf<EmotionRecord>()

    companion object {
        private const val EMOTION_INPUT_REQUEST = 1001
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        fileManager = EmotionFileManager(this)
        chordAnalyzer = EmotionChordAnalyzer()
        chordHistoryManager = ChordHistoryManager(this)

        initViews()
        initChordViews()
        setupClickListeners()
        setupChordClickListeners()
        loadTodayEmotions()
        updateEmotionDisplay()
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        if (requestCode == EMOTION_INPUT_REQUEST && resultCode == RESULT_OK) {
            loadTodayEmotions()
            updateEmotionDisplay()
            updateAddEmotionButton()
        }
    }

    private fun initViews() {
        btnNotification = findViewById(R.id.btnNotification)
        btnSettings = findViewById(R.id.btnSettings)
        emotionStaffView = findViewById(R.id.emotionStaffView)
        emotionTimelineContainer = findViewById(R.id.emotionTimelineContainer)
        tvEmptyMessage = findViewById(R.id.tvEmptyMessage)
        btnAddEmotion = findViewById(R.id.btnAddEmotion)
        btnEmotionTuner = findViewById(R.id.btnEmotionTuner)
    }

    private fun initChordViews() {
        todayChordCard = findViewById(R.id.todayChordCard)
        tvChordSymbol = findViewById(R.id.tvChordSymbol)
        tvChordName = findViewById(R.id.tvChordName)
        tvChordFullName = findViewById(R.id.tvChordFullName)
        tvIntensity = findViewById(R.id.tvIntensity)
        tvChordMessage = findViewById(R.id.tvChordMessage)
        tvEmotionCount = findViewById(R.id.tvEmotionCount)
        tvDominantEmotion = findViewById(R.id.tvDominantEmotion)
        btnPlayChord = findViewById(R.id.btnPlayChord)
        btnShareChord = findViewById(R.id.btnShareChord)
    }

    private fun setupClickListeners() {
        btnNotification.setOnClickListener {
            showNotificationMenu()
        }

        btnSettings.setOnClickListener {
            showSettingsMenu()
        }

        btnAddEmotion.setOnClickListener {
            if (isAllTimeSlotsRecorded()) {
                Toast.makeText(this, "Ïò§ÎäòÏùò Î™®Îì† Í∞êÏ†ïÏù¥ Ïù¥ÎØ∏ Í∏∞Î°ùÎêòÏóàÏñ¥Ïöî! üéµ\nÎÇ¥Ïùº Îòê ÎßåÎÇòÏöî!", Toast.LENGTH_LONG).show()
            } else {
                val intent = Intent(this, EmotionInputActivity::class.java)
                startActivityForResult(intent, EMOTION_INPUT_REQUEST)
            }
        }

        btnEmotionTuner.setOnClickListener {
            startEmotionTuner()
        }

        updateAddEmotionButton()
    }

    private fun setupChordClickListeners() {
        btnPlayChord.setOnClickListener {
            handlePlayChord()
        }

        btnShareChord.setOnClickListener {
            handleShareChord()
        }

        todayChordCard.setOnClickListener {
            showChordDetails()
        }
    }

    private fun startEmotionTuner() {
        if (emotionData.isEmpty()) {
            Toast.makeText(this, "Î®ºÏ†Ä ÌòÑÏû¨ Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌï¥Ï£ºÏÑ∏Ïöî!", Toast.LENGTH_SHORT).show()
            val intent = Intent(this, EmotionInputActivity::class.java)
            startActivityForResult(intent, EMOTION_INPUT_REQUEST)
            return
        }

        val latestEmotion = emotionData.lastOrNull()
        if (latestEmotion != null) {
            val intent = Intent(this, EmotionTunerActivity::class.java)
            intent.putExtra("CURRENT_EMOTION_SYMBOL", latestEmotion.emotionSymbol)
            intent.putExtra("CURRENT_EMOTION_NAME", getEmotionNameFromSymbol(latestEmotion.emotionSymbol))
            startActivity(intent)
        } else {
            Toast.makeText(this, "Í∞êÏ†ï Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
        }
    }

    private fun getEmotionNameFromSymbol(symbol: String): String {
        return when(symbol) {
            "‚ô™" -> "Í∏∞ÏÅ®"
            "‚ô©" -> "ÌèâÏò®"
            "‚ô´" -> "ÏÑ§Î†ò"
            "‚ô≠" -> "Ïä¨Ìîî"
            "‚ôØ" -> "ÌôîÎÇ®"
            "ùÑ¢" -> "Î∂àÏïà"
            "‚ô°" -> "ÏÇ¨Îûë"
            else -> "Ïïå Ïàò ÏóÜÏùå"
        }
    }

    private fun isAllTimeSlotsRecorded(): Boolean {
        val today = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(Date())
        val timeSlots = arrayOf("morning", "afternoon", "evening", "night")

        return timeSlots.all { timeSlot ->
            fileManager.hasEmotionData(today, timeSlot)
        }
    }

    private fun updateAddEmotionButton() {
        if (isAllTimeSlotsRecorded()) {
            btnAddEmotion.text = "üéº Ïò§Îäò Ïó∞Ï£ºÎäî ÎÅùÎÇ¨Ïñ¥Ïöî!"
            btnAddEmotion.alpha = 0.5f
            btnAddEmotion.isEnabled = false
        } else {
            btnAddEmotion.text = "+ Í∞êÏ†ï Í∏∞Î°ùÌïòÍ∏∞"
            btnAddEmotion.alpha = 1.0f
            btnAddEmotion.isEnabled = true
        }
    }

    private fun loadTodayEmotions() {
        emotionData.clear()

        val today = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(Date())
        val savedEmotions = fileManager.loadEmotionsByDate(today)
        emotionData.addAll(savedEmotions)
    }

    private fun updateEmotionDisplay() {
        updateEmotionStaff()
        updateEmotionTimeline()
        updateTodayChord()
        updateAddEmotionButton()
    }

    private fun updateTodayChord() {
        val todayChord = chordAnalyzer.analyzeEmotions(emotionData)
        displayChord(todayChord)

        if (todayChord.emotionCount > 0) {
            chordHistoryManager.saveChordHistory(todayChord)
        }
    }

    private fun displayChord(chord: EmotionChordAnalyzer.EmotionChord) {
        tvChordSymbol.text = chord.chordSymbol
        tvChordName.text = chord.chordName
        tvChordFullName.text = chord.chordFullName
        tvIntensity.text = chord.intensity.split(" ")[0]
        tvChordMessage.text = chord.message

        tvEmotionCount.text = "${chord.emotionCount}Í∞ú Í∞êÏ†ï Í∏∞Î°ù"
        tvDominantEmotion.text = "Ï£ºÏöî: ${chord.dominantEmotion}"

        try {
            val chordColor = Color.parseColor(chord.chordColor)
            tvChordName.setTextColor(chordColor)
            tvChordSymbol.setTextColor(chordColor)
        } catch (e: Exception) {
            tvChordName.setTextColor(ContextCompat.getColor(this, R.color.text_primary))
        }

        if (chord.emotionCount == 0) {
            btnPlayChord.text = "üéµ Ï≤´ Í∞êÏ†ï Í∏∞Î°ùÌïòÍ∏∞"
            btnShareChord.visibility = View.GONE
        } else {
            btnPlayChord.text = "‚ô™ ÏΩîÎìú Îì£Í∏∞"
            btnShareChord.visibility = View.VISIBLE
        }

        animateChordCard()
    }

    private fun animateChordCard() {
        todayChordCard.alpha = 0f
        todayChordCard.scaleX = 0.8f
        todayChordCard.scaleY = 0.8f

        todayChordCard.animate()
            .alpha(1f)
            .scaleX(1f)
            .scaleY(1f)
            .setDuration(500)
            .start()
    }

    private fun handlePlayChord() {
        val currentChord = chordAnalyzer.analyzeEmotions(emotionData)

        if (currentChord.emotionCount == 0) {
            val intent = Intent(this, EmotionInputActivity::class.java)
            startActivityForResult(intent, EMOTION_INPUT_REQUEST)
        } else {
            showChordPlayMessage(currentChord)
        }
    }

    private fun showChordPlayMessage(chord: EmotionChordAnalyzer.EmotionChord) {
        val message = "${chord.chordName} ÏΩîÎìúÍ∞Ä Ïó∞Ï£ºÎê©ÎãàÎã§ üéµ\n${chord.message}"
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun handleShareChord() {
        val currentChord = chordAnalyzer.analyzeEmotions(emotionData)
        val today = SimpleDateFormat("yyyyÎÖÑ MMÏõî ddÏùº", Locale.getDefault()).format(Date())

        val shareText = buildString {
            append("üéµ ${today}Ïùò Í∞êÏ†ï ÏΩîÎìú\n\n")
            append("${currentChord.chordName} (${currentChord.chordFullName})\n")
            append("${currentChord.message}\n\n")
            append("üìä ${currentChord.emotionCount}Í∞ú Í∞êÏ†ï Í∏∞Î°ù\n")
            append("üéº Ï£ºÏöî Í∞êÏ†ï: ${currentChord.dominantEmotion}\n")
            append("üéöÔ∏è Í∞ïÎèÑ: ${currentChord.intensity}\n\n")
            append("#Moderato #Í∞êÏ†ïÏΩîÎìú #${currentChord.chordName}")
        }

        val shareIntent = Intent().apply {
            action = Intent.ACTION_SEND
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, shareText)
        }

        startActivity(Intent.createChooser(shareIntent, "Ïò§ÎäòÏùò Í∞êÏ†ï ÏΩîÎìú Í≥µÏú†ÌïòÍ∏∞"))
    }

    private fun showChordDetails() {
        val currentChord = chordAnalyzer.analyzeEmotions(emotionData)

        val detailMessage = buildString {
            append("üéº ${currentChord.chordName} ÏÉÅÏÑ∏ Ï†ïÎ≥¥\n\n")
            append("üìù Ï†ïÏãù Î™ÖÏπ≠: ${currentChord.chordFullName}\n")
            append("üéµ ÏΩîÎìú Í∏∞Ìò∏: ${currentChord.chordSymbol}\n")
            append("üéöÔ∏è Í∞êÏ†ï Í∞ïÎèÑ: ${currentChord.intensity}\n")
            append("üìä Í∏∞Î°ùÎêú Í∞êÏ†ï: ${currentChord.emotionCount}Í∞ú\n")
            append("üéØ Ï£ºÏöî Í∞êÏ†ï: ${currentChord.dominantEmotion}\n\n")
            append("üí≠ Ïò§ÎäòÏùò Í∞êÏ†ï Ìï¥ÏÑù:\n${currentChord.message}")
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üéµ ${currentChord.chordName}")
        builder.setMessage(detailMessage)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.show()
    }

    private fun updateEmotionTimeline() {
        emotionTimelineContainer.removeAllViews()

        if (emotionData.isEmpty()) {
            tvEmptyMessage.visibility = View.VISIBLE
            return
        }

        tvEmptyMessage.visibility = View.GONE

        emotionData.forEach { emotion ->
            val timelineItem = createTimelineItem(emotion)
            emotionTimelineContainer.addView(timelineItem)
        }
    }

    private fun createTimelineItem(emotion: EmotionRecord): LinearLayout {
        val container = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            gravity = Gravity.CENTER_VERTICAL
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                setMargins(0, 8, 0, 8)
            }
            setPadding(16, 12, 16, 12)
            background = ContextCompat.getDrawable(this@MainActivity, R.drawable.emotion_timeline_bg)
        }

        val timeIcon = TextView(this).apply {
            text = when(emotion.timeOfDay) {
                "morning" -> "üåÖ"
                "afternoon" -> "üåû"
                "evening" -> "üåô"
                "night" -> "üåÉ"
                else -> "‚è∞"
            }
            textSize = 24f
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                setMargins(0, 0, 16, 0)
            }
        }

        val contentContainer = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
        }

        val timeText = TextView(this).apply {
            text = when(emotion.timeOfDay) {
                "morning" -> "ÏïÑÏπ®"
                "afternoon" -> "Ïò§ÌõÑ"
                "evening" -> "Ï†ÄÎÖÅ"
                "night" -> "Î∞§"
                else -> "Í∏∞ÌÉÄ"
            }
            textSize = 16f
            setTextColor(ContextCompat.getColor(this@MainActivity, R.color.text_primary))
            typeface = Typeface.DEFAULT_BOLD
        }

        val emotionContainer = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            gravity = Gravity.CENTER_VERTICAL
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                setMargins(0, 4, 0, 0)
            }
        }

        val emotionIcon = TextView(this).apply {
            text = emotion.emotionSymbol
            textSize = 20f
            setTextColor(getEmotionColor(emotion.emotionSymbol))
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                setMargins(0, 0, 8, 0)
            }
        }

        val emotionText = TextView(this).apply {
            text = emotion.emotionText
            textSize = 14f
            setTextColor(ContextCompat.getColor(this@MainActivity, R.color.text_secondary))
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            maxLines = 1
            ellipsize = android.text.TextUtils.TruncateAt.END
        }

        val buttonContainer = LinearLayout(this).apply {
            orientation = LinearLayout.HORIZONTAL
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT)
        }

        val tunerButton = TextView(this).apply {
            text = "üéöÔ∏è"
            textSize = 16f
            setTextColor(ContextCompat.getColor(this@MainActivity, R.color.secondary_orange))
            background = ContextCompat.getDrawable(this@MainActivity, R.drawable.chord_button_bg)
            setPadding(12, 8, 12, 8)
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                setMargins(4, 0, 4, 0)
            }

            setOnClickListener {
                val intent = Intent(this@MainActivity, EmotionTunerActivity::class.java)
                intent.putExtra("CURRENT_EMOTION_SYMBOL", emotion.emotionSymbol)
                intent.putExtra("CURRENT_EMOTION_NAME", getEmotionNameFromSymbol(emotion.emotionSymbol))
                startActivity(intent)

                Toast.makeText(this@MainActivity, "${getEmotionNameFromSymbol(emotion.emotionSymbol)} Í∞êÏ†ïÏùÑ Ï°∞Ïú®Ìï¥Î≥¥ÏÑ∏Ïöî!", Toast.LENGTH_SHORT).show()
            }
        }

        val editButton = TextView(this).apply {
            text = "‚úèÔ∏è"
            textSize = 14f
            setTextColor(ContextCompat.getColor(this@MainActivity, R.color.text_secondary))
            background = ContextCompat.getDrawable(this@MainActivity, R.drawable.chord_button_bg)
            setPadding(8, 8, 8, 8)
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                setMargins(4, 0, 0, 0)
            }

            setOnClickListener {
                editEmotion(emotion)
            }
        }

        emotionContainer.addView(emotionIcon)
        emotionContainer.addView(emotionText)

        buttonContainer.addView(tunerButton)
        buttonContainer.addView(editButton)

        contentContainer.addView(timeText)
        contentContainer.addView(emotionContainer)

        container.addView(timeIcon)
        container.addView(contentContainer)
        container.addView(buttonContainer)

        container.setOnClickListener {
            val intent = Intent(this, EmotionTunerActivity::class.java)
            intent.putExtra("CURRENT_EMOTION_SYMBOL", emotion.emotionSymbol)
            intent.putExtra("CURRENT_EMOTION_NAME", getEmotionNameFromSymbol(emotion.emotionSymbol))
            startActivity(intent)
        }

        return container
    }

    private fun editEmotion(emotion: EmotionRecord) {
        Toast.makeText(this, "${getTimeOfDayKorean(emotion.timeOfDay)} Í∞êÏ†ïÏùÑ ÏàòÏ†ïÌï¥Ïöî!", Toast.LENGTH_SHORT).show()
        val intent = Intent(this, EmotionInputActivity::class.java)
        intent.putExtra("EDIT_MODE", true)
        intent.putExtra("EDIT_DATE", emotion.date)
        intent.putExtra("EDIT_TIME_OF_DAY", emotion.timeOfDay)
        startActivityForResult(intent, EMOTION_INPUT_REQUEST)
    }

    private fun updateEmotionStaff() {
        val emotionNotes = emotionData.map { emotion ->
            EmotionStaffView.EmotionNote(
                symbol = emotion.emotionSymbol,
                pitch = getEmotionPitch(emotion.emotionSymbol),
                time = when(emotion.timeOfDay) {
                    "morning" -> "AM"
                    "afternoon" -> "PM"
                    "evening" -> "EV"
                    "night" -> "NT"
                    else -> ""
                },
                intensity = getEmotionIntensity(emotion.date, emotion.timeOfDay),
                timeOfDay = emotion.timeOfDay
            )
        }

        val key = determineKey(emotionData)
        val tempo = determineTempo(emotionData)

        emotionStaffView.setEmotions(emotionNotes, key, tempo)
    }

    private fun getEmotionIntensity(date: String, timeOfDay: String): Int {
        return try {
            val fileName = "${date}_${timeOfDay}.txt"
            val fileInput = openFileInput(fileName)
            val content = fileInput.bufferedReader().use { it.readText() }
            fileInput.close()

            val lines = content.split("\n")
            for (line in lines) {
                if (line.startsWith("Í∞ïÎèÑ:")) {
                    val intensityText = line.substringAfter("Í∞ïÎèÑ:").trim()
                    return when {
                        intensityText.contains("pp") -> 1
                        intensityText.contains("p") && !intensityText.contains("pp") -> 2
                        intensityText.contains("mf") -> 3
                        intensityText.contains("f") && !intensityText.contains("ff") -> 4
                        intensityText.contains("ff") -> 5
                        else -> 3
                    }
                }
            }
            3
        } catch (e: Exception) {
            3
        }
    }

    private fun getEmotionPitch(symbol: String): Int {
        return when(symbol) {
            "‚ô™" -> 7
            "‚ô©" -> 5
            "‚ô´" -> 8
            "‚ô≠" -> 2
            "‚ôØ" -> 6
            "ùÑ¢" -> 1
            "‚ô°" -> 6
            else -> 4
        }
    }

    private fun getEmotionColor(symbol: String): Int {
        return when(symbol) {
            "‚ô™" -> ContextCompat.getColor(this, R.color.primary_pink)
            "‚ô©" -> ContextCompat.getColor(this, R.color.primary_purple)
            "‚ô´" -> ContextCompat.getColor(this, R.color.secondary_orange)
            "‚ô≠" -> ContextCompat.getColor(this, android.R.color.holo_blue_dark)
            "‚ôØ" -> ContextCompat.getColor(this, android.R.color.holo_red_dark)
            "ùÑ¢" -> ContextCompat.getColor(this, android.R.color.darker_gray)
            "‚ô°" -> ContextCompat.getColor(this, android.R.color.holo_red_light)
            else -> ContextCompat.getColor(this, R.color.text_primary)
        }
    }

    private fun determineKey(emotions: List<EmotionRecord>): String {
        val happyCount = emotions.count { it.emotionSymbol == "‚ô™" || it.emotionSymbol == "‚ô´" || it.emotionSymbol == "‚ô°" }
        val sadCount = emotions.count { it.emotionSymbol == "‚ô≠" || it.emotionSymbol == "ùÑ¢" }

        return if (happyCount > sadCount) "C Major" else "A Minor"
    }

    private fun determineTempo(emotions: List<EmotionRecord>): String {
        return when(emotions.size) {
            0 -> "Andante"
            1 -> "Moderato"
            2 -> "Allegro"
            else -> "Vivace"
        }
    }

    private fun getTimeOfDayKorean(timeOfDay: String): String {
        return when (timeOfDay) {
            "morning" -> "ÏïÑÏπ®"
            "afternoon" -> "Ïò§ÌõÑ"
            "evening" -> "Ï†ÄÎÖÅ"
            "night" -> "Î∞§"
            else -> "Í∏∞ÌÉÄ"
        }
    }

    private fun showNotificationMenu() {
        val savedDates = fileManager.getAllSavedDates()
        if (savedDates.isEmpty()) {
            Toast.makeText(this, "ÏïÑÏßÅ Ï†ÄÏû•Îêú Í∞êÏ†ï Í∏∞Î°ùÏù¥ ÏóÜÏñ¥Ïöî", Toast.LENGTH_SHORT).show()
            return
        }

        val message = "Ï¥ù ${savedDates.size}ÏùºÏùò Í∞êÏ†ïÏù¥ Í∏∞Î°ùÎêòÏñ¥ ÏûàÏñ¥Ïöî!\nÏµúÍ∑º: ${savedDates.firstOrNull() ?: "ÏóÜÏùå"}"
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    private fun showSettingsMenu() {
        val options = arrayOf("Ï†ÑÏ≤¥ Í∏∞Î°ù Î≥¥Í∏∞", "ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨", "ÏΩîÎìú ÌÜµÍ≥Ñ", "Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨", "ÎèÑÏõÄÎßê")

        val builder = AlertDialog.Builder(this)
        builder.setTitle("ÏÑ§Ï†ï")
        builder.setItems(options) { _, which ->
            when (which) {
                0 -> showAllRecords()
                1 -> showChordHistory()
                2 -> showChordStatistics()
                3 -> showDataCleanup()
                4 -> showHelp()
            }
        }
        builder.show()
    }

    private fun showChordHistory() {
        val history = chordHistoryManager.getRecentChords(30)

        if (history.isEmpty()) {
            Toast.makeText(this, "ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
            return
        }

        val message = buildString {
            append("üéº ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨ (ÏµúÍ∑º 30Ïùº)\n\n")
            history.forEach { entry ->
                append("üìÖ ${entry.date}\n")
                append("üéµ ${entry.chordName} (${entry.chordSymbol})\n")
                append("üìä ${entry.emotionCount}Í∞ú Í∞êÏ†ï, Ï£ºÏöî: ${entry.dominantEmotion}\n")
                append("üí≠ ${entry.message.take(50)}${if (entry.message.length > 50) "..." else ""}\n\n")
            }
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üéº ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨")
        builder.setMessage(message)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.setNegativeButton("ÏÉÅÏÑ∏Î≥¥Í∏∞") { _, _ ->
            showDetailedChordHistory()
        }
        builder.show()
    }

    private fun showDetailedChordHistory() {
        val history = chordHistoryManager.loadChordHistory()

        if (history.isEmpty()) {
            Toast.makeText(this, "ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
            return
        }

        val chordNames = history.map { "${it.date}: ${it.chordName}" }.toTypedArray()

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üéº ÏÉÅÏÑ∏ ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨")
        builder.setItems(chordNames) { _, which ->
            showChordHistoryDetail(history[which])
        }
        builder.setNegativeButton("Îã´Í∏∞", null)
        builder.show()
    }

    private fun showChordHistoryDetail(entry: ChordHistoryManager.ChordHistoryEntry) {
        val detailMessage = buildString {
            append("üéº ${entry.chordName} ÏÉÅÏÑ∏ Ï†ïÎ≥¥\n\n")
            append("üìÖ ÎÇ†Ïßú: ${entry.date}\n")
            append("üéµ Ï†ïÏãù Î™ÖÏπ≠: ${entry.chordFullName}\n")
            append("üéöÔ∏è Í∞êÏ†ï Í∞ïÎèÑ: ${entry.intensity}\n")
            append("üìä Í∏∞Î°ùÎêú Í∞êÏ†ï: ${entry.emotionCount}Í∞ú\n")
            append("üéØ Ï£ºÏöî Í∞êÏ†ï: ${entry.dominantEmotion}\n")
            append("‚è∞ Ï†ÄÏû• ÏãúÍ∞Å: ${entry.timestamp}\n\n")
            append("üí≠ Í∑∏ÎÇ†Ïùò Í∞êÏ†ï Ìï¥ÏÑù:\n${entry.message}")
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üéµ ${entry.chordName} (${entry.date})")
        builder.setMessage(detailMessage)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.setNeutralButton("Í≥µÏú†ÌïòÍ∏∞") { _, _ ->
            shareChordHistory(entry)
        }
        builder.show()
    }

    private fun shareChordHistory(entry: ChordHistoryManager.ChordHistoryEntry) {
        val shareText = buildString {
            append("üéµ ${entry.date}Ïùò Í∞êÏ†ï ÏΩîÎìú\n\n")
            append("${entry.chordName} (${entry.chordFullName})\n")
            append("${entry.message}\n\n")
            append("üìä ${entry.emotionCount}Í∞ú Í∞êÏ†ï Í∏∞Î°ù\n")
            append("üéº Ï£ºÏöî Í∞êÏ†ï: ${entry.dominantEmotion}\n")
            append("üéöÔ∏è Í∞ïÎèÑ: ${entry.intensity}\n\n")
            append("#Moderato #Í∞êÏ†ïÏΩîÎìú #${entry.chordName} #Í∞êÏ†ïÍ∏∞Î°ù")
        }

        val shareIntent = Intent().apply {
            action = Intent.ACTION_SEND
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, shareText)
        }

        startActivity(Intent.createChooser(shareIntent, "Í∞êÏ†ï ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨ Í≥µÏú†ÌïòÍ∏∞"))
    }

    private fun showChordStatistics() {
        val stats = chordHistoryManager.getChordStatistics()

        if (stats.totalDays == 0) {
            Toast.makeText(this, "ÌÜµÍ≥ÑÎ•º ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
            return
        }

        val message = buildString {
            append("üìä ÏΩîÎìú ÌÜµÍ≥Ñ Î∂ÑÏÑù\n\n")
            append("üìÖ Ï¥ù Í∏∞Î°ù ÏùºÏàò: ${stats.totalDays}Ïùº\n")
            append("üèÜ Í∞ÄÏû• ÎßéÏùÄ ÏΩîÎìú: ${stats.mostFrequentChord}\n")
            append("üòä Í∞ÄÏû• ÎßéÏùÄ Í∞êÏ†ï: ${stats.mostFrequentEmotion}\n")
            append("üìà ÌèâÍ∑† Í∞êÏ†ï Í∞úÏàò: ${"%.1f".format(stats.averageEmotionCount)}Í∞ú\n\n")

            append("üéº ÏΩîÎìú Î∂ÑÌè¨:\n")
            stats.chordDistribution.entries.sortedByDescending { it.value }.take(5).forEach { (chord, count) ->
                val percentage = (count * 100.0 / stats.totalDays)
                append("  $chord: ${count}Ìöå (${"%.1f".format(percentage)}%)\n")
            }

            append("\nüòä Í∞êÏ†ï Î∂ÑÌè¨:\n")
            stats.emotionDistribution.entries.sortedByDescending { it.value }.take(5).forEach { (emotion, count) ->
                val percentage = (count * 100.0 / stats.totalDays)
                append("  $emotion: ${count}Ìöå (${"%.1f".format(percentage)}%)\n")
            }
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üìä ÏΩîÎìú ÌÜµÍ≥Ñ")
        builder.setMessage(message)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.setNeutralButton("ÏõîÍ∞Ñ Î∂ÑÏÑù") { _, _ ->
            showMonthlyChordAnalysis()
        }
        builder.show()
    }

    private fun showMonthlyChordAnalysis() {
        val calendar = Calendar.getInstance()
        val currentMonth = SimpleDateFormat("yyyy-MM", Locale.getDefault()).format(calendar.time)
        val startDate = "$currentMonth-01"

        calendar.set(Calendar.DAY_OF_MONTH, calendar.getActualMaximum(Calendar.DAY_OF_MONTH))
        val endDate = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(calendar.time)

        val monthlyHistory = chordHistoryManager.getChordHistoryByDateRange(startDate, endDate)

        if (monthlyHistory.isEmpty()) {
            Toast.makeText(this, "Ïù¥Î≤à Îã¨ ÏΩîÎìú Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
            return
        }

        val message = buildString {
            append("üóìÔ∏è ${SimpleDateFormat("yyyyÎÖÑ MMÏõî", Locale.getDefault()).format(calendar.time)} ÏΩîÎìú Î∂ÑÏÑù\n\n")
            append("üìÖ Í∏∞Î°ù ÏùºÏàò: ${monthlyHistory.size}Ïùº\n\n")

            append("üéº Ïù¥Îã¨Ïùò ÏΩîÎìú Ïó¨Ìñâ:\n")
            monthlyHistory.take(10).forEach { entry ->
                val day = entry.date.substringAfterLast("-")
                append("${day}Ïùº: ${entry.chordName} ${entry.chordSymbol}\n")
            }

            if (monthlyHistory.size > 10) {
                append("... Ïô∏ ${monthlyHistory.size - 10}Ïùº Îçî\n")
            }

            val monthlyChords = monthlyHistory.groupBy { it.chordName }
            val dominantChord = monthlyChords.maxByOrNull { it.value.size }?.key

            append("\nüèÜ Ïù¥Îã¨Ïùò ÎåÄÌëú ÏΩîÎìú: $dominantChord")
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("üóìÔ∏è ÏõîÍ∞Ñ ÏΩîÎìú Î∂ÑÏÑù")
        builder.setMessage(message)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.show()
    }

    private fun showAllRecords() {
        val savedDates = fileManager.getAllSavedDates()
        if (savedDates.isEmpty()) {
            Toast.makeText(this, "Ï†ÄÏû•Îêú Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
            return
        }

        val message = buildString {
            append("üìä Ï†ÑÏ≤¥ Í∞êÏ†ï Í∏∞Î°ù\n\n")
            savedDates.take(10).forEach { date ->
                val emotions = fileManager.loadEmotionsByDate(date)
                append("üìÖ $date: ${emotions.size}Í∞ú Í∞êÏ†ï\n")
                emotions.forEach { emotion ->
                    append("  ${getTimeOfDayKorean(emotion.timeOfDay)}: ${emotion.emotionSymbol} ${emotion.emotionText}\n")
                }
                append("\n")
            }
            if (savedDates.size > 10) {
                append("... Ïô∏ ${savedDates.size - 10}Ïùº Îçî")
            }
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("Ï†ÑÏ≤¥ Í∏∞Î°ù")
        builder.setMessage(message)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.show()
    }

    private fun showDataCleanup() {
        val savedDates = fileManager.getAllSavedDates()
        val chordHistory = chordHistoryManager.loadChordHistory()

        val message = buildString {
            append("üìä Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞:\n")
            append("‚Ä¢ Í∞êÏ†ï Í∏∞Î°ù: ${savedDates.size}Ïùº\n")
            append("‚Ä¢ ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨: ${chordHistory.size}Ïùº\n\n")
            append("Ï†ïÎßêÎ°ú Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†Ïñ¥Ïöî?")
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨")
        builder.setMessage(message)
        builder.setPositiveButton("Ï†ÑÏ≤¥ ÏÇ≠Ï†ú") { _, _ ->
            showDeleteConfirmation()
        }
        builder.setNeutralButton("ÏΩîÎìúÎßå ÏÇ≠Ï†ú") { _, _ ->
            deleteChordHistoryOnly()
        }
        builder.setNegativeButton("Ï∑®ÏÜå", null)
        builder.show()
    }

    private fun showDeleteConfirmation() {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("‚ö†Ô∏è ÏµúÏ¢Ö ÌôïÏù∏")
        builder.setMessage("Ï†ïÎßêÎ°ú Î™®Îì† Í∞êÏ†ï Í∏∞Î°ùÍ≥º ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†Ïñ¥Ïöî?\nÏù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.")
        builder.setPositiveButton("ÏÇ≠Ï†ú") { _, _ ->
            Toast.makeText(this, "Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Í∏∞Îä•ÏùÄ Ï∂îÌõÑ Íµ¨ÌòÑ ÏòàÏ†ïÏûÖÎãàÎã§", Toast.LENGTH_SHORT).show()
        }
        builder.setNegativeButton("Ï∑®ÏÜå", null)
        builder.show()
    }

    private fun deleteChordHistoryOnly() {
        val success = chordHistoryManager.clearAllHistory()
        if (success) {
            Toast.makeText(this, "ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
        }
    }

    private fun showHelp() {
        val helpMessage = buildString {
            append("üéµ Moderato ÏÇ¨Ïö©Î≤ï\n\n")
            append("1. '+ Í∞êÏ†ï Í∏∞Î°ùÌïòÍ∏∞' Î≤ÑÌäºÏúºÎ°ú Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌïòÏÑ∏Ïöî\n")
            append("2. ÏãúÍ∞ÑÎåÄÎ≥ÑÎ°ú Îã§Î•∏ Í∞êÏ†ïÏùÑ Í∏∞Î°ùÌï† Ïàò ÏûàÏñ¥Ïöî\n")
            append("3. Í∞êÏ†ï Í∞ïÎèÑÏôÄ ÌÉúÍ∑∏Î•º ÏÑ§Ï†ïÌï¥Î≥¥ÏÑ∏Ïöî\n")
            append("4. Í∏∞Î°ùÎêú Í∞êÏ†ïÏùÄ ÏïÖÎ≥¥Î°ú ÌëúÌòÑÎê©ÎãàÎã§\n")
            append("5. ÌÉÄÏûÑÎùºÏù∏ÏóêÏÑú Í∞êÏ†ïÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ ÏàòÏ†ïÌï† Ïàò ÏûàÏñ¥Ïöî\n")
            append("6. 'üéöÔ∏è Í∞êÏ†ï Ï°∞Ïú®' Î≤ÑÌäºÏúºÎ°ú Í∞êÏ†ïÏùÑ Ï°∞Ï†àÌïòÏÑ∏Ïöî\n")
            append("7. Ïò§ÎäòÏùò Í∞êÏ†ï ÏΩîÎìúÎ•º ÌôïÏù∏ÌïòÍ≥† Í≥µÏú†Ìï¥Î≥¥ÏÑ∏Ïöî\n")
            append("8. ÏÑ§Ï†ïÏóêÏÑú ÏΩîÎìú ÌûàÏä§ÌÜ†Î¶¨ÏôÄ ÌÜµÍ≥ÑÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî\n\n")
            append("üíæ Î™®Îì† Í∞êÏ†ïÏùÄ ÏûêÎèôÏúºÎ°ú Ï†ÄÏû•Îê©ÎãàÎã§!")
        }

        val builder = AlertDialog.Builder(this)
        builder.setTitle("ÎèÑÏõÄÎßê")
        builder.setMessage(helpMessage)
        builder.setPositiveButton("ÌôïÏù∏", null)
        builder.show()
    }
}